/-
Copyright (c) 2018 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau, Michael Howes

The functor Grp → Ab which is the left adjoint
of the forgetful functor Ab → Grp.
-/

-- TODO:
-- (1) Abelian groups solvable ✓
-- (2) Quotients of solvable groups solvable
-- (3) Subgroups of solvable groups solvable
-- (4) If G is in the middle of a short exact sequence with everything else solvable
--     then G is solvable
-- (5) S_5 is not solvable (A_5 is simple)

-- Small todos:
-- (1) Show that the subgroup generated by the commutators is equal to its normal closure

import group_theory.quotient_group
import tactic.group
open subgroup

universes u v

-- let G be a group
variables (G : Type u) [group G]

/-- The commutator subgroup of a group G is the normal subgroup
  generated by the commutators [p,q]=`p*q*p⁻¹*q⁻¹` -/
@[derive subgroup.normal]
def commutator : subgroup G :=
normal_closure {x | ∃ p q, p * q * p⁻¹ * q⁻¹ = x}

variables {G}

def general_commutator (H₁ : subgroup G) (H₂ : subgroup G) : subgroup G :=
subgroup.closure {x | ∃ (p ∈ H₁) (q ∈ H₂), p * q * p⁻¹ * q⁻¹ = x}

instance general_commutator_normal (H₁ : subgroup G) (H₂ : subgroup G) [h₁ : H₁.normal]
  [h₂ : H₂.normal] : normal (general_commutator H₁ H₂) :=
begin
  let base : set G := {x | ∃ (p ∈ H₁) (q ∈ H₂), p * q * p⁻¹ * q⁻¹ = x},
  suffices h_base : base = group.conjugates_of_set base,
  { dsimp only [general_commutator, ←base],
    rw h_base,
    exact subgroup.normal_closure_normal },
  apply set.subset.antisymm group.subset_conjugates_of_set,
  intros a h,
  rw group.mem_conjugates_of_set_iff at h,
  rcases h with ⟨b, ⟨c, hc, e, he, rfl⟩, d, rfl⟩,
  exact ⟨d * c * d⁻¹, h₁.conj_mem c hc d, d * e * d⁻¹, h₂.conj_mem e he d, by group⟩,
end

lemma general_commutator_eq_normal_closure (H₁ : subgroup G) (H₂ : subgroup G) [H₁.normal]
  [H₂.normal] : general_commutator H₁ H₂ = normal_closure (general_commutator H₁ H₂) :=
eq.symm normal_closure_eq_self_of_normal

lemma general_commutator_eq_normal_closure' (H₁ H₂ : subgroup G) [H₁.normal] [H₂.normal] :
  general_commutator H₁ H₂ = normal_closure {x | ∃ (p ∈ H₁) (q ∈ H₂), p * q * p⁻¹ * q⁻¹ = x} :=
by rw [general_commutator_eq_normal_closure, general_commutator,
  normal_closure_closure_eq_normal_closure]

variables (G)

def nth_commutator (n : ℕ) : subgroup G :=
nat.rec_on n (⊤ : subgroup G) (λ _ H, general_commutator H H)

instance top_normal: (⊤: subgroup G).normal :=
{ conj_mem :=  λ  n mem g, mem_top (g*n *g⁻¹ ), }

lemma nth_commutator_normal (n : ℕ) : (nth_commutator G n).normal :=
begin
  induction n with n ih,
  { change (⊤ : subgroup G).normal,
    exact top_normal G, },
  { haveI : (nth_commutator G n).normal := ih,
    change (general_commutator (nth_commutator G n) (nth_commutator G n)).normal,
    exact general_commutator_normal (nth_commutator G n) (nth_commutator G n), }
end

lemma commutator_eq_general_commutator_top_top :
  commutator G = general_commutator (⊤ : subgroup G) (⊤ : subgroup G) :=
begin
  rw commutator,
  rw general_commutator_eq_normal_closure',
  apply le_antisymm; apply normal_closure_mono,
  { exact λ x ⟨p, q, h⟩, ⟨p, mem_top p, q, mem_top q, h⟩, },
  { exact λ x ⟨p, _, q, _, h⟩, ⟨p, q, h⟩, }
end

lemma commutator_def' : commutator G = subgroup.closure {x : G | ∃ p q, p * q * p⁻¹ * q⁻¹ = x} :=
begin
  rw commutator_eq_general_commutator_top_top,
  rw general_commutator,
  apply le_antisymm; apply closure_mono,
  { exact λ x ⟨p, _, q, _, h⟩, ⟨p, q, h⟩ },
  { exact λ x ⟨p, q, h⟩, ⟨p, mem_top p, q, mem_top q, h⟩ }
end

lemma nth_commutator_zero : nth_commutator G 0 = ⊤ := rfl

lemma nth_commutator_one : nth_commutator G 1 = commutator G :=
eq.symm $ commutator_eq_general_commutator_top_top G

lemma nth_commutator_succ (n : ℕ) :
  nth_commutator G (n + 1) = general_commutator (nth_commutator G n) (nth_commutator G n) := rfl

/-- The abelianization of G is the quotient of G by its commutator subgroup -/
def abelianization : Type u :=
quotient_group.quotient (commutator G)

namespace abelianization

local attribute [instance] quotient_group.left_rel

instance : comm_group (abelianization G) :=
{ mul_comm := λ x y, quotient.induction_on₂' x y $ λ a b,
  begin
    apply quotient.sound,
    apply subset_normal_closure,
    use b⁻¹, use a⁻¹,
    group,
  end,
.. quotient_group.quotient.group _ }

instance : inhabited (abelianization G) := ⟨1⟩

variable {G}

/-- `of` is the canonical projection from G to its abelianization. -/
def of : G →* abelianization G :=
{ to_fun := quotient_group.mk,
  map_one' := rfl,
  map_mul' := λ x y, rfl }

section lift
-- so far -- built Gᵃᵇ and proved it's an abelian group.
-- defined `of : G → Gᵃᵇ`

-- let A be an abelian group and let f be a group hom from G to A
variables {A : Type v} [comm_group A] (f : G →* A)

lemma commutator_subset_ker : commutator G ≤ f.ker :=
begin
  apply normal_closure_le_normal,
  rintros x ⟨p, q, rfl⟩,
  simp [monoid_hom.mem_ker, mul_right_comm (f p) (f q)],
end

/-- If `f : G → A` is a group homomorphism to an abelian group, then `lift f` is the unique map from
  the abelianization of a `G` to `A` that factors through `f`. -/
def lift : abelianization G →* A :=
quotient_group.lift _ f (λ x h, f.mem_ker.2 $ commutator_subset_ker _ h)

@[simp] lemma lift.of (x : G) : lift f (of x) = f x :=
rfl

theorem lift.unique
  (φ : abelianization G →* A)
  -- hφ : φ agrees with f on the image of G in Gᵃᵇ
  (hφ : ∀ (x : G), φ (of x) = f x)
  {x : abelianization G} :
  φ x = lift f x :=
quotient_group.induction_on x hφ

end lift

variables {A : Type v} [monoid A]

theorem hom_ext (φ ψ : abelianization G →* A)
  (h : φ.comp of = ψ.comp of) : φ = ψ :=
begin
  ext x,
  apply quotient_group.induction_on x,
  intro z,
  show φ.comp of z = _,
  rw h,
  refl,
end

end abelianization

section solvable

def is_solvable : Prop := ∃ n : ℕ, nth_commutator G n = (⊥ : subgroup G)

lemma is_solvable_of_comm {G : Type*} [comm_group G] : is_solvable G :=
begin
  use 1,
  rw [eq_bot_iff, nth_commutator_one],
  calc commutator G ≤ (monoid_hom.id G).ker : abelianization.commutator_subset_ker (monoid_hom.id G)
  ... = ⊥ : rfl,
end

end solvable

section subgroup_solvable

variables {G} (H : subgroup G)

def subgroup.lift (K : subgroup H) : subgroup G :=
{ carrier := coe '' (K : set H),
  one_mem' :=
  begin
    rw set.mem_image,
    exact ⟨1, ⟨K.one_mem', by simp⟩⟩,
  end,
  mul_mem' :=
  begin
    rintros _ _ ⟨x, hx, rfl⟩ ⟨y, hy, rfl⟩,
    rw set.mem_image,
    exact ⟨x * y, ⟨K.mul_mem' hx hy, by simp⟩⟩,
  end,
  inv_mem' :=
  begin
    rintros _ ⟨x, hx, rfl⟩,
    rw set.mem_image,
    exact ⟨x⁻¹, ⟨K.inv_mem' hx, by simp⟩⟩,
  end
}

lemma lift_commutes_with_commutator (K₁ K₂ : subgroup H) :
  H.lift (general_commutator K₁ K₂) = general_commutator (H.lift K₁) (H.lift K₂) :=
begin
  apply le_antisymm,
  { intros x hx,
    rcases hx with ⟨x, hx, rfl⟩,
    refine closure_induction hx _ (one_mem _) (λ x y hx hy, mul_mem _ hx hy) (λ x hx, inv_mem _ hx),
    rintros ⟨y, _⟩ ⟨p, hp, q, hq, hy⟩,
    rw general_commutator,
    apply subset_closure,
    exact ⟨p, ⟨p, hp, rfl⟩, q, ⟨q, hq, rfl⟩, by simp only [← coe_mul, ← coe_inv, *]⟩, },
  { rw [general_commutator, closure_le, general_commutator],
    rintros _ ⟨_, ⟨p, hp, rfl⟩, _, ⟨q, hq, rfl⟩, rfl⟩,
    refine ⟨p * q * p⁻¹ * q⁻¹, _, rfl⟩,
    apply subset_closure,
    exact ⟨p, hp, q, hq, rfl⟩, }
end

lemma stupid_lift_lemma (K : subgroup H) (x : H) : x ∈ K ↔ ↑x ∈ H.lift K :=
begin
  rcases x with ⟨x, hx⟩,
  exact ⟨λ h, ⟨⟨x, hx⟩, h, rfl⟩, λ _, by tidy⟩,
end

lemma commutator_mono {H₁ H₂ K₁ K₂ : subgroup G} (h₁ : H₁ ≤ K₁) (h₂ : H₂ ≤ K₂) :
  general_commutator H₁ H₂ ≤ general_commutator K₁ K₂ :=
begin
  apply closure_mono,
  rintros x ⟨p, hp, q, hq, rfl⟩,
  exact ⟨p, h₁ hp, q, h₂ hq, rfl⟩,
end

lemma nth_commutator_sub_of_subgroup (n : ℕ) :
  subgroup.lift H (nth_commutator H n) ≤ nth_commutator G n :=
begin
  induction n with n ih,
  { simp only [nth_commutator_zero, le_top], },
  { simp [nth_commutator_succ, lift_commutes_with_commutator, commutator_mono, *], },
end

theorem subgroup_solvable_of_solvable (h : is_solvable G) : is_solvable H :=
begin
  cases h with n h,
  use n,
  rw eq_bot_iff,
  rintros ⟨x, x_in_H⟩ hx,
  rw mem_bot,
  ext,
  rw [coe_one, coe_mk],
  rw eq_bot_iff at h,
  refine h (nth_commutator_sub_of_subgroup H n _),
  rw stupid_lift_lemma at hx,
  convert hx,
end

end subgroup_solvable

section quotient_solvable

lemma commutator_onto_of_onto (G' : Type*) [group G'] {H₁ H₂ : subgroup G} {K₁ K₂ : subgroup G'}
  (f : G →* G') (h₁ : ∀ y ∈ K₁, ∃ x ∈ H₁, f x = y) (h₂ : ∀ y ∈ K₂, ∃ x ∈ H₂, f x = y) :
  ∀ y ∈ general_commutator K₁ K₂, ∃ x ∈ general_commutator H₁ H₂, f x = y :=
begin
  sorry,
end

lemma nth_commutator_of_onto (G' : Type*) [group G'] (n : ℕ) (f : G →* G')
  (hf : ∀ y, ∃ x, f x = y) : ∀ y ∈ nth_commutator G' n, ∃ x ∈ nth_commutator G n, f x = y :=
begin
  induction n with n ih,
  { intros y hy,
    obtain ⟨x, rfl⟩ := hf y,
    use x,
    rw nth_commutator_zero,
    exact ⟨mem_top x, rfl⟩, },
  { rw nth_commutator_succ,
    rw nth_commutator_succ,
    exact commutator_onto_of_onto G G' f ih ih, },
end

lemma solvable_image_of_solvable (G' : Type*) [group G'] (f : G →* G') (hf : ∀ y, ∃ x, f x = y)
  (h : is_solvable G) : is_solvable G' :=
begin
  cases h with n hn,
  use n,
  rw eq_bot_iff_forall at *,
  intros y hy,
  obtain ⟨x, hx, rfl⟩ := nth_commutator_of_onto G G' n f hf y hy,
  rw [hn x hx, monoid_hom.map_one],
end

lemma solvable_quotient_of_solvable (H : subgroup G) [H.normal] (h : is_solvable G) :
  is_solvable (quotient_group.quotient H) :=
solvable_image_of_solvable G (quotient_group.quotient H) (quotient_group.mk' H) (by tidy) h

end quotient_solvable
