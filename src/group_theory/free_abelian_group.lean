/-
Copyright (c) 2018 Kenny Lau. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kenny Lau

Free abelian groups as abelianization of free groups.
-/
import algebra.pi_instances
import group_theory.free_group
import group_theory.abelianization

universes u v

variables (α : Type u)

/-- Free additive commutative group generated by `α`. -/
def free_abelian_group : Type u :=
additive $ abelianization $ free_group α

instance : add_comm_group (free_abelian_group α) :=
@additive.add_comm_group _ $ abelianization.comm_group _

instance : inhabited (free_abelian_group α) := ⟨0⟩

variable {α}

namespace free_abelian_group

/-- Canonical embedding of `α` into `free_abelian_group α`. -/
def of (x : α) : free_abelian_group α :=
abelianization.of $ free_group.of x

@[elab_as_eliminator]
protected theorem induction_on
  {C : free_abelian_group α → Prop}
  (z : free_abelian_group α)
  (C0 : C 0)
  (C1 : ∀ x, C $ of x)
  (Cn : ∀ x, C (of x) → C (-of x))
  (Cp : ∀ x y, C x → C y → C (x + y)) : C z :=
quotient.induction_on' z $ λ x, free_group.induction_on x C0 C1 Cn $ λ a b ha hb, Cp _ _ ha hb

/-- Every map from `α` to an additive commutative group lifts to an additive
group homomorphism from `free_abelian_group α` to this group. -/
def lift {G : Type v} [add_comm_group G] :
  (α → G) ≃ (free_abelian_group α →+ G) :=
(@free_group.lift α (multiplicative G) _).trans $ abelianization.lift.trans
  ⟨λ f, f.to_additive, λ f, f.to_multiplicative, λ ⟨_, _, _⟩, rfl, λ ⟨_, _, _⟩, rfl⟩

section lift

variables {G : Type v} [add_comm_group G] (f : α → G)

@[simp] lemma lift_symm_apply (f : free_abelian_group α →+ G) : lift.symm f = f ∘ of := rfl

@[simp] lemma lift_comp_of : lift f ∘ of = f := lift.symm_apply_apply f

@[simp] lemma lift_eval_of (x : α) : lift f (of x) = f x :=
congr_fun (lift_comp_of f) x

lemma lift_unique (g : free_abelian_group α →+ G) (hg : ∀ x, g (of x) = f x) :
  g = lift f :=
lift.symm_apply_eq.1 $ funext hg

lemma lift_unique' {g : free_abelian_group α → G} (hg : ∀ x y, g (x + y) = g x + g y)
  (hgf : ∀ x, g (of x) = f x) {x} :
  g x = lift f x :=
add_monoid_hom.ext_iff.1 (lift_unique f (add_monoid_hom.mk' g hg) hgf) x

@[ext] lemma hom_eq {f g : free_abelian_group α →+ G} (h : ∀ x, f (of x) = g (of x)) :
  f = g :=
lift.symm.injective $ funext h

@[simp] lemma lift_of : lift (of : α → free_abelian_group α) = add_monoid_hom.id _ :=
hom_eq $ λ x, by simp

variables {H : Type*} [add_comm_group H]
  
lemma comp_lift (g : G →+ H) (f : α → G) :
  g.comp (lift f) = lift (g ∘ f) :=
by { ext, simp }

lemma hom_map_lift (g : G →+ H) (f : α → G) (a) :
  g (lift f a) = lift (g ∘ f) a :=
add_monoid_hom.ext_iff.1 (comp_lift g f) a

@[simp] lemma lift_add (f g : α → G) : lift (λ x, f x + g x) = lift f + lift g :=
hom_eq $ λ x, by simp

section ring

variables {R : Type*} [ring R]

lemma lift_mul_const (f : α → R) (c : R) (x : free_abelian_group α) :
  lift (λ x, f x * c) x = lift f x * c :=
(hom_map_lift (add_monoid_hom.mul_right c) f x).symm

lemma lift_const_mul (f : α → R) (c : R) (x : free_abelian_group α) :
  lift (λ x, c * f x) x = c * lift f x :=
(hom_map_lift (add_monoid_hom.mul_left c) f x).symm

end ring


/-- Every map from `α` to an additive commutative group lifts to an additive
group homomorphism from `free_abelian_group α` to this group. Moreover, sum of two maps
corresponds to sum of group homomorphisms. -/
def lift_add' : (α → G) ≃+ (free_abelian_group α →+ G) :=
{ map_add' := lift_add, .. lift }

@[simp] lemma coe_lift_add' : ⇑(lift_add' : (α → G) ≃+ _) = (lift : (α → G) ≃ _) := rfl

@[simp] lemma coe_lift_add'_symm :
  ⇑(lift_add' : (α → G) ≃+ _).symm = (lift : (α → G) ≃ _).symm := rfl

@[simp] lemma lift_zero : (lift : (α → G) ≃ _) 0 = 0 := (lift_add' : (α → G) ≃+ _).map_zero

end lift

variables {β : Type u}

instance : monad free_abelian_group.{u} :=
{ pure := λ α, of,
  bind := λ α β x f, lift f x }

@[elab_as_eliminator]
protected theorem induction_on'
  {C : free_abelian_group α → Prop}
  (z : free_abelian_group α)
  (C0 : C 0)
  (C1 : ∀ x, C $ pure x)
  (Cn : ∀ x, C (pure x) → C (-pure x))
  (Cp : ∀ x y, C x → C y → C (x + y)) : C z :=
free_abelian_group.induction_on z C0 C1 Cn Cp

@[simp] lemma map_pure (f : α → β) (x : α) : f <$> (pure x : free_abelian_group α) = pure (f x) :=
lift_eval_of _ _

@[simp] lemma map_zero (f : α → β) : f <$> (0 : free_abelian_group α) = 0 :=
add_monoid_hom.map_zero _

@[simp] lemma map_add (f : α → β) (x y : free_abelian_group α) :
  f <$> (x + y) = f <$> x + f <$> y :=
add_monoid_hom.map_add _ _ _

@[simp] lemma map_neg (f : α → β) (x : free_abelian_group α) : f <$> (-x) = -(f <$> x) :=
add_monoid_hom.map_neg _ _

@[simp] lemma map_sub (f : α → β) (x y : free_abelian_group α) :
  f <$> (x - y) = f <$> x - f <$> y :=
add_monoid_hom.map_sub _ _ _

@[simp] lemma map_of (f : α → β) (y : α) : f <$> of y = of (f y) := rfl

lemma lift_comp {α} {β} {G} [add_comm_group G]
  (f : α → β) (g : β → G) (x : free_abelian_group α) :
  lift (g ∘ f) x = lift g (f <$> x) :=
show lift (g ∘ f) x = (lift g).comp (lift (of ∘ f)) x, from
add_monoid_hom.ext_iff.1 (by rw [comp_lift, ← function.comp.assoc (lift g), lift_comp_of]) x

@[simp] lemma pure_bind (f : α → free_abelian_group β) (x) : pure x >>= f = f x :=
lift_eval_of _ _

@[simp] lemma zero_bind (f : α → free_abelian_group β) : 0 >>= f = 0 :=
(lift f).map_zero

@[simp] lemma add_bind (f : α → free_abelian_group β) (x y : free_abelian_group α) :
  x + y >>= f = (x >>= f) + (y >>= f) :=
(lift f).map_add x y

@[simp] lemma neg_bind (f : α → free_abelian_group β) (x : free_abelian_group α) :
  -x >>= f = -(x >>= f) :=
(lift f).map_neg x

@[simp] lemma sub_bind (f : α → free_abelian_group β) (x y : free_abelian_group α) :
  x - y >>= f = (x >>= f) - (y >>= f) :=
(lift f).map_sub _ _

@[simp] lemma pure_seq (f : α → β) (x : free_abelian_group α) : pure f <*> x = f <$> x :=
pure_bind _ _

@[simp] lemma zero_seq (x : free_abelian_group α) : (0 : free_abelian_group (α → β)) <*> x = 0 :=
zero_bind _

@[simp] lemma add_seq (f g : free_abelian_group (α → β)) (x : free_abelian_group α) :
  f + g <*> x = (f <*> x) + (g <*> x) :=
add_bind _ _ _

@[simp] lemma neg_seq (f : free_abelian_group (α → β)) (x : free_abelian_group α) :
  -f <*> x = -(f <*> x) :=
neg_bind _ _

@[simp] lemma sub_seq (f g : free_abelian_group (α → β)) (x : free_abelian_group α) :
  f - g <*> x = (f <*> x) - (g <*> x) :=
sub_bind _ _ _

instance is_add_group_hom_seq (f : free_abelian_group (α → β)) : is_add_group_hom ((<*>) f) :=
{ map_add := λ x y, by { unfold_projs, simp } }

@[simp] lemma seq_zero (f : free_abelian_group (α → β)) : f <*> 0 = 0 :=
is_add_group_hom.map_zero _

@[simp] lemma seq_add (f : free_abelian_group (α → β)) (x y : free_abelian_group α) :
  f <*> (x + y) = (f <*> x) + (f <*> y) :=
is_add_hom.map_add _ _ _

@[simp] lemma seq_neg (f : free_abelian_group (α → β)) (x : free_abelian_group α) :
  f <*> (-x) = -(f <*> x) :=
is_add_group_hom.map_neg _ _

@[simp] lemma seq_sub (f : free_abelian_group (α → β)) (x y : free_abelian_group α) :
  f <*> (x - y) = (f <*> x) - (f <*> y) :=
is_add_group_hom.map_sub _ _ _

instance : is_lawful_monad free_abelian_group.{u} :=
{ id_map := λ α x, free_abelian_group.induction_on' x (map_zero id) (λ x, map_pure id x)
    (λ x ih, by rw [map_neg, ih]) (λ x y ihx ihy, by rw [map_add, ihx, ihy]),
  pure_bind := λ α β x f, pure_bind f x,
  bind_assoc := λ α β γ x f g, free_abelian_group.induction_on' x
    (by iterate 3 { rw zero_bind }) (λ x, by iterate 2 { rw pure_bind })
    (λ x ih, by iterate 3 { rw neg_bind }; rw ih)
    (λ x y ihx ihy, by iterate 3 { rw add_bind }; rw [ihx, ihy]) }

instance : is_comm_applicative free_abelian_group.{u} :=
{ commutative_prod := λ α β x y, free_abelian_group.induction_on' x
    (by rw [map_zero, zero_seq, seq_zero])
    (λ p, by rw [map_pure, pure_seq]; exact free_abelian_group.induction_on' y
      (by rw [map_zero, map_zero, zero_seq])
      (λ q, by rw [map_pure, map_pure, pure_seq, map_pure])
      (λ q ih, by rw [map_neg, map_neg, neg_seq, ih])
      (λ y₁ y₂ ih1 ih2, by rw [map_add, map_add, add_seq, ih1, ih2]))
    (λ p ih, by rw [map_neg, neg_seq, seq_neg, ih])
    (λ x₁ x₂ ih1 ih2, by rw [map_add, add_seq, seq_add, ih1, ih2]) }
variable (α)

instance [has_mul α] : has_mul (free_abelian_group α) :=
⟨λ x, lift $ λ x₂, lift (λ x₁, of $ x₁ * x₂) x⟩

lemma mul_def [has_mul α] (x y : free_abelian_group α) :
  x * y = (lift $ λ x₂, lift (λ x₁, of $ x₁ * x₂) x) y :=
rfl

lemma of_mul [has_mul α] (x y : α) : of (x * y) = of x * of y := rfl

instance [monoid α] : semigroup (free_abelian_group α) :=
{ mul := (*),
  mul_assoc := λ x y z, begin
    simp only [mul_def, hom_map_lift, (∘)],
    refine add_monoid_hom.ext_iff.1 (hom_eq $ λ _, _) _,
    simp only [lift_eval_of, mul_assoc],
  end }

instance [monoid α] : ring (free_abelian_group α) :=
begin
  refine_struct { one := free_abelian_group.of 1,
    .. free_abelian_group.add_comm_group α,
    .. free_abelian_group.semigroup α, .. },
  field one_mul { intro x, simp [mul_def, hom_map_lift] },
  field mul_one { intro x, simp [mul_def, hom_map_lift, (∘)] },
  field left_distrib { intros x y z, exact (lift _).map_add _ _ },
  field right_distrib { intros x y z,
    unfold semigroup.mul add_comm_group.add add_group.add add_monoid.add add_semigroup.add,
    simp [mul_def, hom_map_lift] }
end

lemma one_def [monoid α] : (1 : free_abelian_group α) = free_abelian_group.of 1 := rfl

/-- Embedding of a monoid `α` to `free_abelian_group α` as a monoid homomorphism. -/
def of_hom [monoid α] : α →* free_abelian_group α :=
⟨of, rfl, of_mul α⟩

@[simp] lemma coe_of_hom [monoid α] : ⇑(of_hom α) = of := rfl

instance [comm_monoid α] : comm_ring (free_abelian_group α) :=
{ mul_comm := λ x y,
    calc x * y = (lift (λ x₂, (lift (λ x₁, of (x₂ * x₁))) x)) y : by simp only [mul_def, mul_comm]
    ... = y * x : by { simp only [mul_def], simp only [of_mul, lift_const_mul, lift_mul_const] },
  .. free_abelian_group.ring α }

section ring_lift

variables {M : Type*} {R : Type*} [monoid M] [ring R]

/-- If `M` is a monoid, then any monoid homomorphism from `M` to a ring `R` lifts to a ring
homomorphism from `free_abelian_group M` to the same ring. -/
def ring_lift : (M →* R) ≃ (free_abelian_group M →+* R) :=
{ to_fun := λ f,
  { to_fun := lift f,
    map_one' := by simp [one_def],
    map_mul' := λ x y,
      begin
        simp only [mul_def],
        simp only [hom_map_lift, (∘), lift_eval_of, f.map_mul],
        simp only [of_mul, lift_mul_const, lift_const_mul]
      end,
    .. lift f },
  inv_fun := λ f, (f : free_abelian_group M →* R).comp (of_hom M),
  left_inv := λ f, monoid_hom.coe_inj $ lift.symm_apply_apply f,
  right_inv := λ f, ring_hom.coe_add_monoid_hom_inj $
    lift.apply_symm_apply (f : free_abelian_group M →+ R) }

end ring_lift

end free_abelian_group
