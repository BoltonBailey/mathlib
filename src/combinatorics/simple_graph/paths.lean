import combinatorics.simple_graph.basic
import combinatorics.simple_graph.hom
import combinatorics.simple_graph.subgraph
open simple_graph

namespace simple_graph
universes u v

/-- thinking of a `path_graph (n + m)` as being a path of length n
followed by a path of length m, includes the first path. --/
def path_graph.incl₁ (n m : ℕ) : ↟(path_graph n) →g ↟(path_graph (n + m)) :=
{ to_fun := λ v, v,
  map_rel' := sorry }

def path_graph.incl₂ (n m : ℕ) : ↟(path_graph m) →g ↟(path_graph (n + m)) :=
{ to_fun := λ v, n + v,
  map_rel' := sorry }

variables (G : simple_graph)

/-
The composition of paths, following `pn` first and then `pm`.
-/
def walk_join {n m : ℕ} (pn : ↟(path_graph n) →g G) (pm : ↟(path_graph m) →g G) : ↟(path_graph (n+m)) →g G :=
{ to_fun := λ v, if h : ↑v < n
                 then pn ⟨v, by linarith [h]⟩
                 else pm (by { cases v with v hv, rw [nat.add_assoc, nat.add_comm] at hv,
                               apply fin.sub_nat n ⟨v, hv⟩, dsimp at h, push_neg at h, exact h }),
  map_rel' := begin
    rintros ⟨v, hv⟩ ⟨w, hw⟩ h,
    simp, --split_ifs,
--    {apply pn.map_adj',   },
    sorry,
  end }

/--
"Flip over" the elements of `fin (n + 1)`, reversing `0` and `n`.
-/
def fin.flip (n : ℕ) : fin (n + 1) → fin (n + 1) := λ v, ((n - (v : ℕ) : ℕ) : fin (n + 1))
lemma fin.flip.invol (n : ℕ) : function.involutive (fin.flip n) :=
begin
  intro v, dsimp [fin.flip],
  rw fin.coe_coe_of_lt, swap, exact nat.sub_lt_succ n ↑v,
  cases v,
  convert_to ↑v_val = _, dsimp,
  have h : n - (n - v_val) = v_val, { have : v_val ≤ n, linarith, omega, },
  rw h, apply subtype.val_injective, dsimp,
  exact fin.coe_coe_of_lt v_property,
end

/--
A path graph is isomorphic to itself where the endpoints are swapped.
-/
def path_graph.invol (n : ℕ) : ↟(path_graph n) ≃g ↟(path_graph n) :=
{ to_fun := fin.flip n,
  inv_fun := fin.flip n,
  left_inv := fin.flip.invol n,
  right_inv := fin.flip.invol n,
  map_rel_iff' := begin
    intros v w, simp, sorry,
--    split, rintros ⟨h₁, h₂⟩,
--    cases h₂, rw h₂.1 at h₁ ⊢, dunfold fin.flip, sorry, sorry, sorry,
  end }

lemma path_graph.invol.prop₁ (n : ℕ) : (path_graph.invol n) 0 = n := by tidy
lemma path_graph.invol.prop₂ (n : ℕ) : (path_graph.invol n) n = 0 :=
begin
  change fin.flip n n = 0,
  dunfold fin.flip,
  apply subtype.val_injective, dsimp,
  sorry,
--  rw fin.coe_val_of_lt, rw fin.coe_coe_of_lt; linarith, omega,
end

/--
A walk of length `n` in a graph between vertices `v` and `w` is a sequence of `n + 1` vertices,
each related to the next by adjacency -- the `n` counts the edges along the way.
We model a walk as a graph homomorphism from a length-`n` path graph.
-/
def walk (n : ℕ) (v w : V G) := { f : ↟(path_graph n) →g G // v = f 0 ∧ w = f n }

/--
Reverse a walk.
-/
def walk.symm {n : ℕ} {v w : V G} (p : walk G n v w) : walk G n w v :=
⟨p.val.comp ↑(path_graph.invol n), begin
  simp, erw [path_graph.invol.prop₁ n, path_graph.invol.prop₂ n],
  use [p.2.2, p.2.1],
end⟩

/--
A path of length `n` in a graph between vertices `v` and `w` is a sequence of `n + 1` *distinct* vertices,
each related to the next by adjacency -- the `n` counts the edges along the way.
We model a path as a graph embedding from a length-`n` path graph.
-/
def path (n : ℕ) (v w : V G) := { f : ↟(path_graph n) →g G // function.injective f ∧ v = f 0 ∧ w = f n }

/-- The relation that there exists a walk of any length between two vertices. -/
def exists_walk : V G → V G → Prop := λ v w, nonempty (Σ (n : ℕ), walk G n v w)

/-- The relation that there exists a path of any length between two vertices. -/
def exists_path : V G → V G → Prop := λ v w, nonempty (Σ (n : ℕ), path G n v w)

@[refl] lemma exists_walk.refl (v : V G) : exists_walk G v v :=
by { use [0, λ _, v], delta path_graph, sorry, sorry, }

@[symm] lemma exists_walk.symm ⦃v w : V G⦄ (hvw : exists_walk G v w) : exists_walk G w v :=
by { tactic.unfreeze_local_instances, cases hvw, rcases hvw with ⟨n, p⟩, use [n, walk.symm G p], }

@[trans] lemma exists_walk.trans ⦃u v w : V G⦄ (huv : exists_walk G u v) (hvw : exists_walk G v w) : exists_walk G u w :=
begin
  tactic.unfreeze_local_instances, cases hvw, rcases hvw with ⟨m, pv⟩,
  tactic.unfreeze_local_instances, cases huv, rcases huv with ⟨n, pu⟩,
  --rcases huv with ⟨n, ⟨pu⟩⟩, rcases hvw with ⟨m, ⟨pv⟩⟩,
  use n+m,
  -- now need to concatenate walks  probably better to define path concatenation elsewhere and then use it here!
  sorry
end

lemma exists_walk.is_equivalence : equivalence (exists_walk G) :=
mk_equivalence _ (exists_walk.refl G) (exists_walk.symm G) (exists_walk.trans G)

def exists_walk.setoid : setoid (V G) := setoid.mk _ (exists_walk.is_equivalence G)

lemma exists_path_eq_exists_walk : exists_path G = exists_walk G :=
begin
  ext v w,
  sorry,
end

/--
The equivalence relation generated by `adj G` is another way `exists_walk G` could be defined.
-/
lemma exists_walk_eq_eqv_gen : exists_walk G = eqv_gen G.adj :=
begin
  sorry
end

/--
Quotient of the vertex type by existence of walks.
-/
def connected_components := quotient (exists_walk.setoid G)

/-- Determines if a graph is connected -/
def is_connected : Prop := ∀ v w, exists_walk G v w

/-- The graph does not contain a cycle -/
def is_acyclic : Prop := ∀ (n : ℕ) (h : 3 ≤ n) (f : ↟(cycle_graph n h) →g G), ¬function.injective f

/-- A tree is an acyclic connected graph -/
def is_tree : Prop := is_connected G ∧ is_acyclic G



end simple_graph
